---
title: 前缀和-差分-离散化
top: 35000
date: 2024-05-23 14:04:19
tags:
---

<!---->

<!--more-->

本节的知识不多，理解起来也较为简单，主要的难点在于灵活使用，之后的学习中会有很多题目与此有关。

## 数组上的前缀和与差分

一维的差分与前缀和相对简单。

### 前缀和

前缀和，即前缀的和 ~~（废话）~~ 。

对于一个数组 $a_{1 \sim n}$，它的前缀和数组 $sum$ 定义为（令 $sum_{0} = 0$）：

$$
\begin{aligned}
sum_{i} &= \sum_{j = 1}^{i} a_{j} \\\\
      &=\begin{cases}
       a_{1} & i=1 \\\\
       \sum_{j = 1}^{i - 1} (a_{j}) + a_{i} & i > 1 
      \end{cases} \\\\
      &= sum_{i - 1} + a_{i}
\end{aligned}
$$

在上面的推导中，我们直接得到了 $sum_{i}$ 的递推公式：$sum_{i} = sum_{i - 1} + a_{i}$，这样就可以在 $O(n)$ 时间内得到整个数组的前缀和数组。

**前缀和的用处：**

使用前缀和可以快速求出数组某个子段的区间和：$\sum_{i = L}^{R} = sum_{R}-sum_{L-1}$，这为后面树状数组、线段树等数据结构的建立打下了基础。


### 差分

差分相当于前缀和的逆操作。

一个数组 $a$ 的差分数组 $b$ 定义为： 
$$
b_{i} = \begin{cases}
a_{1} & i = 1\\\\
a_{i} - a_{i - 1} & \texttt{other}
\end{cases}
$$


可以发现：

$$
\begin{aligned}
\sum_{i = 1}^{i} b_{i} &= a_{1} + a_{2} - a_{1} + a_{3} - a_{2} + \dots + a_{i} - a_{i - 1} \\\\ 
&=a_{i}
\end{aligned}
$$

即**差分数组的前缀和就是原数组**。


既然如此，差分数组维护的东西我们初始就知道，为什么还需要这个算法呢？

可以发现，如果我们需要将数组某个子段 $L\sim R$ 的所有元素加上 $x$，在差分数组上只需要更改 $b_{L}$ 和 $b_{R + 1}$，而如果维护原数组则需要更改 $R-L+1$ 个元素，这大大减小了维护的时间复杂度。

不过之前我们的前缀和并不能实时维护，等到学习树状数组的时候我们会给出具体的讲解，此处了解思路即可。



## 二维的前缀和


二维的差分现阶段没有什么意义，这里只讲解前缀和：

二维的数组上，前缀和定义没有太大不同，不过推导和应用时略微复杂：

$$
\begin{aligned}
sum_{i,j} = \sum_{x = 1}^{i} \sum_{y = 1}^{j} a_{x,y}
          =  sum_{i,j-1}+sum_{i-1,j}-sum_{i-1,j-1} + a_{i,j}
\end{aligned}
$$

以 $(x,y)$ 为左上角，$X,Y$ 为右下角的矩阵所有元素和为：

$$
sum_{X,Y}-sum_{x-1,Y}-sum_{X,y-1}+sum_{x-1,y-1}
$$

上面的推导可以自己根据定义画图理解，画出图形很容易理解。

{%note%}
### 例题

{% lg /images/logo.png %}
P50 最大正方形 | https://oj.cnryh.cn/problem#/P50 | 11 Online Judge
{% endlg %}

{% tabs P50 %}
<!-- tab 题意简述 -->

给定一个 $n \times m$（$1\leq n,m \leq 200$） 的 $\text{01}$ 矩阵（所有元素均为 $0$ 或 $1$），求出最大的 $l$ 满足：

- $1 \leq l \leq \min(n,m)$
- 原矩阵内存在一个 **各边均与矩阵的边平行**、边长为 $l$ 的正方形，满足该正方形内所有元素均为 $1$。
<!-- endtab -->
<!-- tab 题解 -->
发现数据范围很小，可以枚举正方形的左上角和边长，时间复杂度为 $O(n^3)$，问题转化为快速判断当前枚举到的正方形内是否全为 $1$。

一个正方形内全为 $1$ 等价于这个正方形内的元素和与面积相等，因此我们可以轻松的通过预处理前缀和来判断。
<!-- endtab -->
{%endtabs%}
{%endnote%}

## 离散化

离散化适用于值域较大，在 **部分处理（需要时仍可以获取原来的数据）** 时只考虑元素 **相对大小** 而不考虑 **实际大小** 的问题。

离散化的实现基于二分（用于确定元素的相对大小），具体过程如下：

1. 用另一个数组 $b$ 暂存原数组 $a$ 中的所有元素。
    ```cpp
    for(int i = 1;i <= n;i++)
    {
        b[i] = a[i];
    }
    ```
2. 将所有元素排序：
    ```cpp
    sort(b + 1,b + n + 1);
    ```
3. 将所有元素去重，得到元素集合及元素个数：
    ```cpp
    int tot = unique(b + 1,b + n + 1) - b - 1;
    ```
    {%note primary `unique` 函数%}
    `unique` 函数的作用是将所有重复的元素移动到数组末尾，**需要注意 `unique` 函数只对排好序的数组有效**。

    `unique` 函数的返回值是**重复的元素移动后**第一个重复元素的迭代器，在该位置**之前所有的元素不重复**。

    根据迭代器（这里理解为下标即可）的可减性可以得到数组中互不相同元素的个数。
    {%endnote%}
4. 获取原数组中每个数的相对大小
    这里我们使用 `lower_bound` 函数实现二分。

    {%note primary `lower_bound` 和 `upper_bound` 函数%}
    这两个函数都用于在数组中查找元素，但作用略有不同：
    用法： `lower_bound(begin,end,num)`，`upper_bound(begin,end,num)`。

    **在从小到大排序的数组中**，`lower_bound(begin,end,num)` 会返回数组中第一个大于**或等于** $num$ 的元素迭代器，而 `upper_bound(begin,end,num)` 会返回第一个大于 $num$ 的元素迭代器。

    根据迭代器的可减性可以得到该元素在数组中的位置：`lower_bound(b + 1,b + tot + 1,num) - b - 1`。
    {%endnote%}

    ```cpp
    for(int i = 1;i <= n;i++)
    {
        a[i] = lower_bound(b + 1,b + tot + 1,a[i]) - b;
        // 注意这里不是 -b-1，如果 -b-1 则最小的元素变为 0，我们希望最小的元素变为 1
    }
    ```


这样离散化就完成了，最终 $a$ 数组的全部元素均在 $1 \sim tot \leq n$ 内，值域减小。

本节的内容在之后还会频繁使用，此处暂不给出题目。